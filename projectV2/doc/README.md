### Project: Image Compression with Quadtrees

### ESIEE PARIS - C Programming 2023-2024

-----
#### RAMANANTSOA RaphaÃ«l
#### CHAUDRON Paul-Henri
-----

### Main Objective

Develop a graphical application capable of encoding, decoding, and compressing images using quadtrees. Through this project, we used concepts of file manipulation, image processing, and pixel management, particularly with the MLV graphical library.

## User Manual

### Compiling the Program

To compile the files, use the following command:
```sh
make
```

The program runs with the following command:
```sh
bin/quadtree <image_file>
```
- `<image_file>`: Specifies the image to load into the application. All files to be loaded are in the `img/input/` folder.

Documentation generated by Doxygen is available with the following command:
```sh
make doc
```
__This rule requires the Doxygen package on your machine__

### Project Architecture

We decided to divide our project into several different modules to ensure better organization and maintainability:

- **controller**: Manages interactions between the model and the view, as well as user events.
- **quadtree**: Manages the quadtree data structure and associated operations, such as image compression and decompression.
- **heap**: Manages the priority queue data structures (heap) used to optimize certain operations on quadtrees.
- **view**: Manages the user interface and display using the MLV library.

### Module Details

#### **Controller Module**

The **Controller** module is responsible for coordinating between the model modules (quadtree and heap) and the view module. It also handles user events and orchestrates the application's flow.

**Functions:**
- `void run_application(MLV_Image *image)`: Runs the application using an image.

#### **Quadtree Module**

The **Quadtree** module is responsible for managing the quadtree data structure. It includes functions for creating, manipulating, compressing, and decompressing quadtrees.

**Functions:**
- `MLV_Color average_color(MLV_Image *image, int x, int y, int size)`: Calculates the average color of an image region.
- `double color_distance(MLV_Color c1, MLV_Color c2)`: Calculates the distance between two colors.
- `double calculate_error(MLV_Image *image, int x, int y, int size, MLV_Color avg_color)`: Calculates the color error for a given region.
- `QuadtreeNode* create_quadtree_node(int x, int y, int size, MLV_Color color, double error)`: Creates a quadtree node.
- `QuadtreeNode* build_quadtree(MLV_Image *image, int x, int y, int size, MaxHeap* heap)`: Builds a quadtree from the image.
- `void free_quadtree(QuadtreeNode *node)`: Frees the memory associated with a quadtree.
- `void minimize_with_loss(QuadtreeNode* root, MLV_Image *image)`: Minimizes the quadtree with loss.
- `double quadtree_distance(QuadtreeNode* t1, QuadtreeNode* t2)`: Calculates the distance between two quadtrees.
- `QuadtreeNode* draw_quadtree_no_loss(MLV_Image *image)`: Draws a quadtree without loss.
- `void draw_quadtree_with_loss(QuadtreeNode* quadtree, MLV_Image *image)`: Draws a quadtree with loss.
- `void subdivide_and_draw(MLV_Image *image, MaxHeap* heap)`: Subdivides and draws the image.
- `void save_quadtree_binary(FILE *file, QuadtreeNode *node)`: Saves the quadtree in binary format.
- `void save_image_quadtree(const char *filename, QuadtreeNode *quadtree)`: Saves an image as a quadtree.
- `const char* get_file_extension(const char *filename)`: Retrieves a file's extension.
- `void save_quadtree_binary_bw(FILE *file, QuadtreeNode *node)`: Saves the quadtree in binary format for a black-and-white image.
- `void save_image_quadtree_bw(const char *filename, QuadtreeNode *quadtree)`: Saves a black-and-white image as a quadtree.
- `void save_quadtree_as_graph(FILE *file, QuadtreeNode *node)`: Saves the quadtree as a graph.
- `void save_image_quadtree_graph(const char *filename, QuadtreeNode *quadtree)`: Saves an image as a quadtree graph.
- `QuadtreeNode* load_quadtree_binary(FILE *file, int size, int x, int y)`: Loads a quadtree from a binary file.
- `QuadtreeNode* load_quadtree_binary_bw(FILE *file, int size, int x, int y)`: Loads a black-and-white quadtree from a binary file.
- `QuadtreeNode* load_image_quadtree(const char *filename)`: Loads an image as a quadtree.
- `QuadtreeNode* load_image_quadtree_bw(const char *filename)`: Loads a black-and-white image as a quadtree.
- `QuadtreeNode* load_quadtree_graph(FILE *file)`: Loads a quadtree from a graph.
- `void assign_ids(QuadtreeNode *node, int *current_id)`: Assigns IDs to quadtree nodes.

#### **Heap Module**

The **Heap** module manages priority queue data structures used to optimize certain operations on quadtrees. It provides functions to insert, delete, and manage elements in a heap.

**Functions:**
- `MaxHeap* create_max_heap(int capacity)`: Creates a new priority queue (heap).
- `void max_heapify(MaxHeap* heap, int idx)`: Maintains the heap property at a given index.
- `void insert_max_heap(MaxHeap* heap, QuadtreeNode* node)`: Inserts an element into the heap.
- `QuadtreeNode* extract_max(MaxHeap* heap)`: Extracts the element with the highest priority from the heap.

#### **View Module**

The **View** module is responsible for managing the user interface and display using the MLV library. It contains functions necessary for displaying images, quadtrees, and user interface elements.

**Functions:**
- `void draw_quadtree(QuadtreeNode *node)`: Draws a quadtree node.
- `void draw_entire_quadtree(QuadtreeNode *node)`: Draws the entire quadtree.
- `void draw_buttons()`: Draws user interface buttons.
- `int handle_button_click(int x, int y)`: Handles button clicks.
- `Uint8 MLV_get_red(MLV_Color color)`: Retrieves the red component of a color.
- `Uint8 MLV_get_green(MLV_Color color)`: Retrieves the green component of a color.
- `Uint8 MLV_get_blue(MLV_Color color)`: Retrieves the blue component of a color.
- `Uint8 MLV_get_alpha(MLV_Color color)`: Retrieves the alpha component of a color.

### Structures Used

- **Quadtree Module**
```c
typedef struct QuadtreeNode {
    int x, y, size;
    MLV_Color color;
    double error;
    struct QuadtreeNode *children[4];
    int id;
} QuadtreeNode;
```

- **Heap Module**
```c
typedef struct {
    QuadtreeNode** nodes;
    int size;
    int capacity;
} MaxHeap;
```

### Methods Used

For the successful completion of this project, we referred to the documentation of the **MLV graphical library**.

Once the program is launched, the user is greeted by the application menu. The options allow for compressing an image using a quadtree from different sources (image, **.qtn** or **.qtc** file). After making a selection, the image is displayed, and the user can start the compression, save the image, and view it again.

### Difficulties Encountered

We spent considerable time understanding the workings of quadtrees and assimilating the explanations provided in the project brief. Once this was achieved, we focused on visualizing the compression behavior to choose a breadth-first traversal over a depth-first traversal. The minimization part is yet to be completed. We faced numerous challenges in handling minimization with loss. Despite multiple tests, due to time constraints, we could not finalize the display of compressed images with loss.

### GitHub

We adopted a process of committing turn by turn, but initially encountered issues with managing commits, adds, pushes, and pulls. We worked together at the start of the project until completing Level 2. Level 3 was developed in several versions and remotely, complicating task distribution and time management. Nonetheless, we are satisfied with the work accomplished for the previous levels.

### Conclusion

This project aimed to develop a graphical application in C capable of encoding, decoding, and compressing images using quadtrees. We organized our code into several modules (controller, quadtree, heap, and view) for better clarity and maintainability.

The main challenges were understanding and implementing quadtrees, especially for lossy compression. Although we overcame several technical obstacles, the minimization of quadtrees still requires improvements.

Using GitHub for version control helped us structure our work, despite initial difficulties with versioning commands.

In summary, this project allowed us to apply advanced programming concepts and work effectively as a team.

 The foundations laid will enable future improvements, particularly in optimizing and managing quadtrees with loss.

---